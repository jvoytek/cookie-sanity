CREATE TABLE IF NOT EXISTS "public"."sellers" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "profile" "uuid",
    "first_name" character varying NOT NULL,
    "last_name" character varying NOT NULL,
    "preferred_name" character varying,
    "season" bigint DEFAULT '1'::bigint NOT NULL,
    "email" text
);


ALTER TABLE "public"."sellers" OWNER TO "postgres";


ALTER TABLE "public"."sellers" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."sellers_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


ALTER TABLE ONLY "public"."sellers"
    ADD CONSTRAINT "sellers_pkey" PRIMARY KEY ("id");


ALTER TABLE ONLY "public"."sellers"
    ADD CONSTRAINT "sellers_profile_fkey" FOREIGN KEY ("profile") REFERENCES "public"."profiles"("id") on delete cascade;


ALTER TABLE ONLY "public"."sellers"
    ADD CONSTRAINT "sellers_season_fkey" FOREIGN KEY ("season") REFERENCES "public"."seasons"("id") on delete cascade;


ALTER TABLE "public"."sellers" ENABLE ROW LEVEL SECURITY;

-- Create seller_requests view to expose limited seller information for public requests
CREATE OR REPLACE VIEW "public"."seller_requests" 
with (security_invoker = on) AS
SELECT 
    s.id,
    s.first_name,
    s.season
FROM "public"."sellers" s
INNER JOIN "public"."seasons" se ON s.season = se.id
WHERE se.publish_girl_request_form = true;

GRANT SELECT ON "public"."seller_requests" TO anon, authenticated;

CREATE POLICY "Allow public read of id, first_name, and season" ON "public"."sellers"
FOR SELECT USING (id > 0); -- Example policy: only allow non-negative IDs
